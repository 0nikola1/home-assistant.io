<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: How-To | Home Assistant]]></title>
  <link href="https://home-assistant.io/blog/categories/how-to/atom.xml" rel="self"/>
  <link href="https://home-assistant.io/"/>
  <updated>2016-08-22T07:26:42+00:00</updated>
  <id>https://home-assistant.io/</id>
  <author>
    <name><![CDATA[Home Assistant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Github-style calendar heatmap of device data]]></title>
    <link href="https://home-assistant.io/blog/2016/08/19/github-style-calendar-heatmap-of-device-data/"/>
    <updated>2016-08-19T06:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2016/08/19/github-style-calendar-heatmap-of-device-data</id>
    <content type="html"><![CDATA[<p>Thanks to <a href="https://github.com/kireyeu">Anton Kireyeu</a> we are able to present another awesome <a href="https://jupyter.org/">Jupyter notebook</a>. I guess that you all know the graph which Github is using to visualize your commits per day over a time-line. It’s a so-called <a href="https://en.wikipedia.org/wiki/Heat_map">heatmap</a>. If there are more commits, it’s getting hotter. The latest <a href="http://nbviewer.jupyter.org/github/home-assistant/home-assistant-notebooks/blob/master/DataExploration-2/DataExploration-2.ipynb">notebook</a> is capable to do the same thing for your devices. To be more precise, for the hours your devices are home.</p>

<p class="img">
<img src="https://home-assistant.io/images/blog/2016-08-data-exploration/heatmap.png" />
Heatmap
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[We Have Apps Now]]></title>
    <link href="https://home-assistant.io/blog/2016/08/16/we-have-apps-now/"/>
    <updated>2016-08-16T10:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2016/08/16/we-have-apps-now</id>
    <content type="html"><![CDATA[<p>I have been working on a new subsystem to complement Home Assistant’s Automation and Scripting components. <code>AppDaemon</code> is a python daemon that consumes events from Home Assistant and feeds them to snippets of python code called “Apps”. An App is a Python class that is instantiated possibly multiple times from <code>AppDaemon</code> and registers callbacks for various system events. It is also able to inspect and set state and call services. The API provides a rich environment suited to home automation tasks that can also leverage all the power of Python.</p>

<!--more-->

<h2><a class='title-link' name='another-take-on-automation' href='#another-take-on-automation'></a> Another Take on Automation </h2>

<p>If you haven’t yet read Paulus’ excellent Blog entry on <a href="https://home-assistant.io/blog/2016/01/19/perfect-home-automation/">Perfect Home Automation</a> I would encourage you to take a look. As a veteran of several Home Automation systems with varying degrees success, it was this article more than anything else that convinced me that Home Assistant had the right philosophy behind it and was on the right track. One of the most important points made is that being able to control your lights from your phone, 9 times out of 10 is harder than using a lightswitch - where Home Automation really comes into its own is when you start removing the need to use a phone or the switch - the “Automation” in Home Automation. A surprisingly large number of systems out there miss this essential point and have limited abilities to automate anything which is why a robust and open system such as Home Assistant is such an important part of the equation to bring this all together in the vast and chaotic ecosystem that is the “Internet of Things”.</p>

<p>So given the importance of Automation, what should Automation allow us to do? I am a pragmatist at heart so I judge individual systems by the ease of accomplishing a few basic but representative tasks:</p>

<ul>
  <li>Can the system respond to presence or absence of people?</li>
  <li>Can I turn a light on at Sunset +/- a certain amount of time?</li>
  <li>Can I arrive home in light or dark and have the lights figure out if they should be on or off?</li>
  <li>As I build my system out, can I get the individual pieces to co-operate and use and re-use (potentially complex) logic to make sure everything works smoothly?</li>
  <li>Is it open and expandable?</li>
  <li>Does it run locally without any reliance on the cloud?</li>
</ul>

<p>In my opinion, Home Assistant accomplishes the majority of these very well with a combination of Automations, Scripts and Templates, and it’s Restful API.</p>

<p>So why <code>AppDaemon</code>? <code>AppDaemon</code> is not meant to replace Home Assistant Automations and Scripts, rather complement them. For a lot of things, automations work well and can be very succinct. However, there is a class of more complex automations for which they become harder to use, and appdeamon then comes into its own. It brings quite a few things to the table:</p>

<ul>
  <li>New paradigm - some problems require a procedural and/or iterative approach, and <code>AppDaemon</code> Apps are a much more natural fit for this. Recent enhancements to Home Assistant scripts and templates have made huge strides, but for the most complex scenarios, Apps can do things that Automations can’t</li>
  <li>Ease of use - <code>AppDaemon</code>’s API is full of helper functions that make programming as easy and natural as possible. The functions and their operation are as “Pythonic” as possible, experienced Python programmers should feel right at home.</li>
  <li>Reuse - write a piece of code once and instantiate it as an app as many times as you need with different parameters e.g. a motion light program that you can use in 5 different places around your home. The code stays the same, you just dynamically add new instances of it in the config file</li>
  <li>Dynamic - <code>AppDaemon</code> has been designed from the start to enable the user to make changes without requiring a restart of Home Assistant, thanks to it’s loose coupling. However, it is better than that - the user can make changes to code and <code>AppDaemon</code> will automatically reload the code, figure out which Apps were using it and restart them to use the new code without the need to restart <code>AppDaemon</code> itself. It is also possible to change parameters for an individual or multiple apps and have them picked up dynamically, and for a final trick, removing or adding apps is also picked up dynamically. Testing cycles become a lot more efficient as a result.</li>
  <li>Complex logic - Python’s If/Else constructs are clearer and easier to code for arbitrarily complex nested logic</li>
  <li>Durable variables and state - variables can be kept between events to keep track of things like the number of times a motion sensor has been activated, or how long it has been since a door opened</li>
  <li>All the power of Python - use any of Python’s libraries, create your own modules, share variables, refactor and re-use code, create a single app to do everything, or multiple apps for individual tasks - nothing is off limits!</li>
</ul>

<p>It is in fact a testament to Home Assistant’s open nature that a component like <code>AppDaemon</code> can be integrated so neatly and closely that it acts in all ways like an extension of the system, not a second class citizen. Part of the strength of Home Assistant’s underlying design is that it makes no assumptions whatever about what it is controlling or reacting to, or reporting state on. This is made achievable in part by the great flexibility of Python as a programming environment for Home Assistant, and carrying that forward has enabled me to use the same philosophy for <code>AppDaemon</code> - it took surprisingly little code to be able to respond to basic events and call services in a completely open ended manner - the bulk of the work after that was adding additonal functions to make things that were already possible easier.</p>

<h2><a class='title-link' name='how-it-works' href='#how-it-works'></a> How it Works </h2>

<p>The best way to show what <code>AppDaemon</code> does is through a few simple examples.</p>

<h3><a class='title-link' name='sunrisesunset-lighting' href='#sunrisesunset-lighting'></a> Sunrise/Sunset Lighting </h3>

<p>Lets start with a simple App to turn a light on every night at sunset and off every morning at sunrise. Every App when first started will have its <code>initialize()</code> function called which gives it a chance to register a callback for <code>AppDaemons</code>’s scheduler for a specific time. In this case we are using <code>run_at_sunrise()</code> and <code>run_at_sunset()</code> to register 2 separate callbacks. The argument <code>0</code> is the number of seconds offset from sunrise or sunset and can be negative or positive. For complex intervals it can be convenient to use Python’s <code>datetime.timedelta</code> class for calculations. When sunrise or sunset occurs, the appropriate callback function, <code>sunrise_cb()</code> or <code>sunset_cb()</code>  is called which then makes a call to Home Assistant to turn the porch light on or off by activating a scene. The variables <code>args["on_scene"]</code> and <code>args["off_scene"]</code> are passed through from the configuration of this particular App, and the same code could be reused to activate completely different scenes in a different version of the App.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">import</span> <span class="include">appapi</span>

<span class="keyword">class</span> <span class="class">OutsideLights</span>(appapi.AppDaemon):

  <span class="keyword">def</span> <span class="function">initialize</span>(<span class="predefined-constant">self</span>):
    <span class="predefined-constant">self</span>.run_at_sunrise(<span class="predefined-constant">self</span>.sunrise_cb, <span class="integer">0</span>)
    <span class="predefined-constant">self</span>.run_at_sunset(<span class="predefined-constant">self</span>.sunset_cb, <span class="integer">0</span>)
    
  <span class="keyword">def</span> <span class="function">sunrise_cb</span>(<span class="predefined-constant">self</span>, args, kwargs):
    <span class="predefined-constant">self</span>.turn_on(<span class="predefined-constant">self</span>.args[<span class="string"><span class="delimiter">&quot;</span><span class="content">off_scene</span><span class="delimiter">&quot;</span></span>])

  <span class="keyword">def</span> <span class="function">sunset_cb</span>(<span class="predefined-constant">self</span>, args, kwargs):
    <span class="predefined-constant">self</span>.turn_on(<span class="predefined-constant">self</span>.args[<span class="string"><span class="delimiter">&quot;</span><span class="content">on_scene</span><span class="delimiter">&quot;</span></span>])

</pre></div>
</div>
</div>

<p>This is also fairly easy to achieve with Home Assistant automations, but we are just getting started.</p>

<h3><a class='title-link' name='motion-light' href='#motion-light'></a> Motion Light </h3>

<p>Our next example is to turn on a light when motion is detected and it is dark, and turn it off after a period of time. This time, the <code>initialize()</code> function registers a callback on a state change (of the motion sensor) rather than a specific time. We tell <code>AppDaemon</code> that we are only interested in state changes where the motion detector comes on by adding an additional parameter to the callback registration - <code>new = "on"</code>. When the motion is detected, the callack function <code>motion()</code> is called, and we check whether or not the sun has set using a built-in convenience function: <code>sun_down()</code>. Next, we turn the light on with <code>turn_on()</code>, then set a timer using <code>run_in()</code> to turn the light off after 60 seconds, which is another call to the scheduler to execute in a set time from now, which results in <code>AppDaemon</code> calling <code>light_off()</code> 60 seconds later using the <code>turn_off()</code> call to actually turn the light off. This is still pretty simple in code terms:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">import</span> <span class="include">appapi</span>

<span class="keyword">class</span> <span class="class">MotionLights</span>(appapi.AppDaemon):

  <span class="keyword">def</span> <span class="function">initialize</span>(<span class="predefined-constant">self</span>):
    <span class="predefined-constant">self</span>.listen_state(<span class="predefined-constant">self</span>.motion, <span class="string"><span class="delimiter">&quot;</span><span class="content">binary_sensor.drive</span><span class="delimiter">&quot;</span></span>, new = <span class="string"><span class="delimiter">&quot;</span><span class="content">on</span><span class="delimiter">&quot;</span></span>)
  
  <span class="keyword">def</span> <span class="function">motion</span>(<span class="predefined-constant">self</span>, entity, attribute, old, new, kwargs):
    <span class="keyword">if</span> <span class="predefined-constant">self</span>.sun_down():
      <span class="predefined-constant">self</span>.turn_on(<span class="string"><span class="delimiter">&quot;</span><span class="content">light.drive</span><span class="delimiter">&quot;</span></span>)
      <span class="predefined-constant">self</span>.run_in(<span class="predefined-constant">self</span>.light_off, <span class="integer">60</span>)
  
  <span class="keyword">def</span> <span class="function">light_off</span>(<span class="predefined-constant">self</span>, kwargs):
    <span class="predefined-constant">self</span>.turn_off(<span class="string"><span class="delimiter">&quot;</span><span class="content">light.drive</span><span class="delimiter">&quot;</span></span>)
</pre></div>
</div>
</div>

<p>This is starting to get a little more complex in Home Assistant automations requiring an Automation rule and two separate scripts.</p>

<p>Now lets extend this with a somewhat artificial example to show something that is simple in <code>AppDaemon</code> but very difficult if not impossible using automations. Lets warn someone inside the house that there has been motion outside by flashing a lamp on and off 10 times. We are reacting to the motion as before by turning on the light and setting a timer to turn it off again, but in addition, we set a 1 second timer to run <code>flash_warning()</code> which when called, toggles the inside light and sets another timer to call itself a second later. To avoid re-triggering forever, it keeps a count of how many times it has been activated and bales out after 10 iterations.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">import</span> <span class="include">appapi</span>

<span class="keyword">class</span> <span class="class">FlashyMotionLights</span>(appapi.AppDaemon):

  <span class="keyword">def</span> <span class="function">initialize</span>(<span class="predefined-constant">self</span>):
    <span class="predefined-constant">self</span>.listen_state(<span class="predefined-constant">self</span>.motion, <span class="string"><span class="delimiter">&quot;</span><span class="content">binary_sensor.drive</span><span class="delimiter">&quot;</span></span>, new = <span class="string"><span class="delimiter">&quot;</span><span class="content">on</span><span class="delimiter">&quot;</span></span>)
  
  <span class="keyword">def</span> <span class="function">motion</span>(<span class="predefined-constant">self</span>, entity, attribute, old, new, kwargs):
    <span class="keyword">if</span> <span class="predefined-constant">self</span>.self.sun_down():
      <span class="predefined-constant">self</span>.turn_on(<span class="string"><span class="delimiter">&quot;</span><span class="content">light.drive</span><span class="delimiter">&quot;</span></span>)
      <span class="predefined-constant">self</span>.run_in(<span class="predefined-constant">self</span>.light_off, <span class="integer">60</span>)
      <span class="predefined-constant">self</span>.flashcount = <span class="integer">0</span>
      <span class="predefined-constant">self</span>.run_in(<span class="predefined-constant">self</span>.flash_warning, <span class="integer">1</span>)
  
  <span class="keyword">def</span> <span class="function">light_off</span>(<span class="predefined-constant">self</span>, kwargs):
    <span class="predefined-constant">self</span>.turn_off(<span class="string"><span class="delimiter">&quot;</span><span class="content">light.drive</span><span class="delimiter">&quot;</span></span>)
    
  <span class="keyword">def</span> <span class="function">flash_warning</span>(<span class="predefined-constant">self</span>, kwargs):
    <span class="predefined-constant">self</span>.toggle(<span class="string"><span class="delimiter">&quot;</span><span class="content">light.living_room</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-constant">self</span>.flashcount += <span class="integer">1</span>
    <span class="keyword">if</span> <span class="predefined-constant">self</span>.flashcount &lt; <span class="integer">10</span>:
      <span class="predefined-constant">self</span>.run_in(<span class="predefined-constant">self</span>.flash_warning, <span class="integer">1</span>)
</pre></div>
</div>
</div>

<p>Of course if I wanted to make this App or its predecessor reusable I would have provided parameters for the sensor, the light to activate on motion, the warning light and even the number of flashes and delay between flashes.</p>

<p>In addition, Apps can write to <code>AppDaemon</code>’s logfiles, and there is a system of constraints that allows yout to control when and under what circumstances Apps and callbacks are active to keep the logic clean and simple.</p>

<p>I have spent the last few weeks moving all of my (fairly complex) automations over to <code>APPDaemon</code> and so far it is working very reliably.</p>

<p>Some people will maybe look at all of this and say “what use is this, I can already do all of this”, and that is fine, as I said this is an alternative not a replacement, but I am hopeful that for some users this will seem a more natural, powerful and nimble way of building potentially very complex automations.</p>

<p>If this has whet your appetite, feel free to give it a try. You can find it, <a href="https://github.com/acockburn/appdaemon">here</a>, including full installation instructions, an API reference, and a number of fully fleshed out examples.</p>

<p>Happy Automating!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ESP8266 and MicroPython - Part 1]]></title>
    <link href="https://home-assistant.io/blog/2016/07/28/esp8266-and-micropython-part1/"/>
    <updated>2016-07-28T04:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2016/07/28/esp8266-and-micropython-part1</id>
    <content type="html"><![CDATA[<p><img src="https://home-assistant.io/images/blog/2016-07-micropython/micropython.png" style="clear: right; border:none; box-shadow: none; float: right; margin-bottom: 12px;" width="200" /><br />
The first release of Micropython for ESP8266 was delivered a couple of weeks ago. The <a href="http://docs.micropython.org/en/latest/esp8266/esp8266_contents.html">documentation</a> covers a lot of ground. This post is providing only a little summary which should get you started.</p>

<p>Until a couple of weeks ago, the pre-built MicroPython binary for the ESP8266 was only available to backers. This has changed now and it is available to the public for <a href="https://micropython.org/download/#esp8266">download</a>.</p>

<!--more-->

<p>The easiest way is to use <a href="https://github.com/themadinventor/esptool">esptool.py</a> for firmware handling tasks. First erase the flash:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ sudo python esptool.py --port /dev/ttyUSB0 erase_flash
esptool.py v1.0.2-dev
Connecting...
Erasing flash (this may take a while)...
</pre></div>
</div>
</div>

<p>and then load the firmware. You may adjust the file name of the firmware binary.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ sudo python esptool.py --port /dev/ttyUSB0 --baud 460800 write_flash --flash_size=8m 0 esp8266-2016-07-10-v1.8.2.bin
esptool.py v1.2-dev
Connecting...
Running Cesanta flasher stub...
Flash params set to 0x0020
Writing 540672 @ 0x0... 540672 (100 %)
Wrote 540672 bytes at 0x0 in 13.1 seconds (330.8 kbit/s)...
Leaving...
</pre></div>
</div>
</div>

<p>Now reset the device. You should then be able to use the <a href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/repl.html#getting-a-micropython-repl-prompt">REPL (Read Evaluate Print Loop)</a>. On Linux there is <code>minicom</code> or <code>picocom</code>, on a Mac you can use <code>screen</code> (eg. <code>screen /dev/tty.SLAB_USBtoUART 115200</code>), and on Windows there is Putty to open a serial connection and get the REPL prompt.</p>

<p>The <a href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/repl.html#webrepl-a-prompt-over-wifi">WebREPL</a> work over a wireless connection and allows easy access to a prompt in your browser. An instance of the WebREPL client is hosted at <a href="http://micropython.org/webrepl">http://micropython.org/webrepl</a>. Alternatively, you can create a local clone of their <a href="https://github.com/micropython/webrepl">GitHub repository</a>. This is neccessary if your want to use the command-line tool <code>webrepl_cli.py</code> which is mentionend later in this post.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ sudo minicom -D /dev/ttyUSB0
#4 ets_task(4020e374, 29, 3fff70e8, 10)                                                          
WebREPL daemon started on ws://192.168.4.1:8266
Started webrepl in setup mode
could not open file 'main.py' for reading

#5 ets_task(4010035c, 3, 3fff6360, 4)
MicroPython v1.8.2-9-g805c2b9 on 2016-07-10; ESP module with ESP8266
Type &quot;help()&quot; for more information.
&gt;&gt;&gt; 
</pre></div>
</div>
</div>

<p class="note">
The public build of the firmware may be different than the firmware distributed to the backers of the campaign. Especially in regard of the <a href="http://docs.micropython.org/en/latest/esp8266/py-modindex.html">available modules</a>, turned on debug messages, and alike. Also, the WebREPL may not be started by default.
</p>

<p>Connect a LED to pin 5 (or another pin of your choosing) to check if the ESP8266 is working as expected.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>&gt;&gt;&gt; <span class="keyword">import</span> <span class="include">machine</span>
&gt;&gt;&gt; pin = machine.Pin(<span class="integer">5</span>, machine.Pin.OUT)
&gt;&gt;&gt; pin.high()
</pre></div>
</div>
</div>

<p>You can toogle the LED by changing its state with <code>pin.high()</code> and <code>pin.low()</code>.</p>

<p>Various ESP8266 development board are shipped with an onboard photocell or a light dependent resistors (LDR) connected to the analog pin of your ESP8266 check if you are able to obtain a value.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>&gt;&gt;&gt; <span class="keyword">import</span> <span class="include">machine</span>
&gt;&gt;&gt; brightness = machine.ADC(<span class="integer">0</span>)
&gt;&gt;&gt; brightness.read()
</pre></div>
</div>
</div>

<p>Make sure that you are familiar with REPL and WebREPL because this will be needed soon. Keep in mind the password for the WebREPL access.</p>

<p>Read the <a href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/network_basics.html">instructions</a> about how to setup your wireless connection. Basically you need to upload a <code>boot.py</code> file to the microcontroller and this file is taking care of the connection setup. Below you find a sample which is more or less the same as shown in the <a href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/network_basics.html#configuration-of-the-wifi">documentation</a>.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">def</span> <span class="function">do_connect</span>():
    <span class="keyword">import</span> <span class="include">network</span>

    SSID = <span class="string"><span class="delimiter">'</span><span class="content">SSID</span><span class="delimiter">'</span></span>
    PASSWORD = <span class="string"><span class="delimiter">'</span><span class="content">PASSWORD</span><span class="delimiter">'</span></span>

    sta_if = network.WLAN(network.STA_IF)
    ap_if = network.WLAN(network.AP_IF)
    <span class="keyword">if</span> ap_if.active():
        ap_if.active(<span class="predefined-constant">False</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> sta_if.isconnected():
        print(<span class="string"><span class="delimiter">'</span><span class="content">connecting to network...</span><span class="delimiter">'</span></span>)
        sta_if.active(<span class="predefined-constant">True</span>)
        sta_if.connect(SSID, PASSWORD)
        <span class="keyword">while</span> <span class="keyword">not</span> sta_if.isconnected():
            <span class="keyword">pass</span>
    print(<span class="string"><span class="delimiter">'</span><span class="content">Network configuration:</span><span class="delimiter">'</span></span>, sta_if.ifconfig())
</pre></div>
</div>
</div>

<p>Upload this file with <code>webrepl_cli.py</code> or the WebREPL:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ python webrepl_cli.py boot.py 192.168.4.1:/boot.py
</pre></div>
</div>
</div>

<p>If you reboot, you should see your current IP address in the terminal.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>&gt;&gt;&gt; Network configuration: ('192.168.0.10', '255.255.255.0', '192.168.0.1', '192.168.0.1')
</pre></div>
</div>
</div>

<p>First let’s create a little consumer for Home Assistant sensor’s state. The code to place in <code>main.py</code> is a mixture of code from above and the <a href="/developers/rest_api/">RESTful API</a> of Home Assistant. If the temperature in the kitchen is higher than 20 °C then the LED connected to pin 5 is switched on.</p>

<p class="note">
If a module is missing then you need to download is it from <a href="https://github.com/micropython/micropython-lib">MicroPython Library overview</a> and upload it to the ESP8266 with <code>webrepl_cli.py</code> manually.
</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="comment"># Sample code to request the state of a Home Assistant entity.</span>

API_PASSWORD = <span class="string"><span class="delimiter">'</span><span class="content">YOUR_PASSWORD</span><span class="delimiter">'</span></span>
URL = <span class="string"><span class="delimiter">'</span><span class="content">http://192.168.0.5:8123/api/states/</span><span class="delimiter">'</span></span>
ENTITY = <span class="string"><span class="delimiter">'</span><span class="content">sensor.kitchen_temperature</span><span class="delimiter">'</span></span>
TIMEOUT = <span class="integer">30</span>
PIN = <span class="integer">5</span>

<span class="keyword">def</span> <span class="function">get_data</span>():
    <span class="keyword">import</span> <span class="include">urequests</span>
    url = <span class="string"><span class="delimiter">'</span><span class="content">{}{}</span><span class="delimiter">'</span></span>.format(URL, ENTITY)
    headers = {<span class="string"><span class="delimiter">'</span><span class="content">x-ha-access</span><span class="delimiter">'</span></span>: API_PASSWORD,
               <span class="string"><span class="delimiter">'</span><span class="content">content-type</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">application/json</span><span class="delimiter">'</span></span>}
    resp = urequests.get(URL, headers=headers)
    <span class="keyword">return</span> resp.json()[<span class="string"><span class="delimiter">'</span><span class="content">state</span><span class="delimiter">'</span></span>]

<span class="keyword">def</span> <span class="function">main</span>():
    <span class="keyword">import</span> <span class="include">machine</span>
    <span class="keyword">import</span> <span class="include">time</span>

    pin = machine.Pin(PIN, machine.Pin.OUT)
    <span class="keyword">while</span> <span class="predefined-constant">True</span>:
        <span class="keyword">try</span>:
            <span class="keyword">if</span> <span class="predefined">int</span>(get_data()) &gt;= <span class="integer">20</span>:
                pin.high()
            <span class="keyword">else</span>:
                pin.low()
        <span class="keyword">except</span> <span class="exception">TypeError</span>:
            <span class="keyword">pass</span>
        time.sleep(TIMEOUT)

<span class="keyword">if</span> __name__ == <span class="string"><span class="delimiter">'</span><span class="content">__main__</span><span class="delimiter">'</span></span>:
    print(<span class="string"><span class="delimiter">'</span><span class="content">Get the state of {}</span><span class="delimiter">'</span></span>.format(ENTITY))
    main()
</pre></div>
</div>
</div>

<p>Upload <code>main.py</code> the same way as <code>boot.py</code>. After a reboot (<code>&gt;&gt;&gt; import machine</code> and <code>&gt;&gt;&gt; machine.reboot()</code>) or power-cycling your physical notifier is ready.</p>

<p>If you run into trouble, press “Ctrl+c” in the REPL to stop the execution of the code, enter <code>&gt;&gt;&gt; import webrepl</code> and <code>&gt;&gt;&gt; webrepl.start()</code>, and upload your fixed file.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IoT Data Exploration with Jupyter Notebooks]]></title>
    <link href="https://home-assistant.io/blog/2016/07/23/internet-of-things-data-exploration-with-jupyter-notebooks/"/>
    <updated>2016-07-23T18:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2016/07/23/internet-of-things-data-exploration-with-jupyter-notebooks</id>
    <content type="html"><![CDATA[<p><em>This is the first blog post by Anton Kireyeu. A new contributor to Home Assistant who will focus on exploring and visualizing Home Assistant data.</em></p>

<p>As we learned in the recent <a href="https://home-assistant.io/blog/2016/07/19/visualizing-your-iot-data/">blog post by Fabian</a>, all operational data of your Home Assistant application is stored locally and is available for exploration. Our first steps were querying data with the <a href="http://sqlitebrowser.org/">DB Browser for SQLite</a>, exporting the data extract as a CSV file and graphing in LibreOffice. But what else can be done with this data and what tools are there available?</p>

<p>This post will help you get set up using a few popular data scientist tools to allow you to locally process your data:</p>

<ul>
  <li> <a href="http://pandas.pydata.org/">Pandas</a>: an open source tool for data analysis for Python</li>
  <li> <a href="http://matplotlib.org/">matplotlib</a>: a Python plotting library</li>
  <li> <a href="https://jupyter.org/">Jupyter notebook</a>: application for creation and sharing of documents containing live code, visualizations and explanatory text</li>
</ul>

<p class="img">
<img src="https://home-assistant.io/images/blog/2016-07-data-exploration/graph.png" />
One of the graphs created with this tutorial.
</p>

<p><em>TL; DR: Use <a href="http://nbviewer.jupyter.org/github/home-assistant/home-assistant-notebooks/blob/master/DataExploration-1/DataExploration-1.ipynb">this Jupyter Notebook</a> to visualize of your data</em></p>

<!--more-->

<h3><a class='title-link' name='dependencies' href='#dependencies'></a> Dependencies </h3>

<p>In order to run the provided Jupyter notebook, please make sure you have the following applications/libraries installed on your computer:</p>

<ul>
  <li>Pandas</li>
  <li>NumPy</li>
  <li>Matplotlib</li>
  <li>SQLAlchemy</li>
  <li>Jupyter</li>
</ul>

<p>As a Windows user myself, I find the easiest, quickest and most hassle-free way of installing all of these dependencies is to use <a href="https://winpython.github.io/">WinPython</a>. This free open-source portable distribution includes all of the dependencies required for this notebook, as well as a few other essential Python libraries you may require for data exploration in the future.</p>

<h4><a class='title-link' name='why-jupyter' href='#why-jupyter'></a> Why Jupyter? </h4>

<p>While all Home Assistant implementations can have varying setup, components and scripts, the underlying data structure is standardized and well-defined. This allows us to write Python code that is environmentally agnostic. Wrapping it in a Jupyter notebook ensures the code, visualizations and directions/explanations are kept digestible and neatly-packaged. One of the amazing features of Jupyter is the ability to change code as you go along, customizing all outputs and visualizations on the fly!</p>

<h4><a class='title-link' name='where-do-i-start' href='#where-do-i-start'></a> Where do I start? </h4>

<p>This tutorial is based around a heavily commented Jupyter Notebook that we created. So to get started, you will have to open that:</p>

<ul>
  <li><a href="http://nbviewer.jupyter.org/github/home-assistant/home-assistant-notebooks/blob/master/DataExploration-1/DataExploration-1.ipynb">download the tutorial Jupyter Notebook</a> (leads to preview page, from there click download top-right)</li>
  <li>launch the Jupyter Notebook App</li>
  <li>Click the ‘upload’ button to add the downloaded notebook to Jupyter</li>
  <li>Adjust the <code>DB_URL</code> at the beginning of the notebook to point at your Home Assistant database</li>
  <li>Select in top menu: Cell -&gt; Run All</li>
</ul>

<p>That’s it! The included code will walk you through importing the required libraries, show running raw SQL against your local database, plotting basic data from the states table, and in the end output a few plots of changes for every entity in your system as well as the mean daily value for the past 20 days.</p>

<p>After just those few steps, you will be greeted with beautiful formatted data like this:</p>

<p class="img">
<img src="https://home-assistant.io/images/blog/2016-07-data-exploration/graph.png" />
One of the graphs created with this tutorial.
</p>

<h4><a class='title-link' name='whats-next' href='#whats-next'></a> What’s next? </h4>

<p>Thanks to the magic of Jupyter, all of the code is customizable: want to selectively display your data, only covering a specific entity? Sure thing! Want to change the properties of the plots? No problem!</p>

<p>While you learn and explore your IoT data, we will be working on providing more ready-to-use Jupyter Notebooks. Feel free to ask questions or provide suggestions. Would you like to see a specific visualization? Is there a particular facet of data you’re interested in? Let’s talk about it, let’s dive into the world of data together!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualize your IoT data]]></title>
    <link href="https://home-assistant.io/blog/2016/07/19/visualizing-your-iot-data/"/>
    <updated>2016-07-19T16:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2016/07/19/visualizing-your-iot-data</id>
    <content type="html"><![CDATA[<p><img src="https://home-assistant.io/images/blog/2016-07-reporting/mpl-sensor.png" style="clear: right; border:none; box-shadow: none; float: right; margin-bottom: 12px;" width="200" /></p>

<p>The <a href="/components/history/">history component</a> is tracking everything that is going on within Home Assistant. This means that you have access to all stored information about your home. Our history is not a full-fledged graphical processing and visualization component as you may know from systems and network monitoring tools. The current limitation is that you only can select a day for a visual output of your information and not a period. Also, there is no possibility to drill down on a specific entity.</p>

<p>This blog post will show you ways to export data for reporting, visualization, or further analysis of automation rules.</p>

<!--more-->

<p>In this blog post I use the temperature of the <a href="https://en.wikipedia.org/wiki/Aare">Aare</a> river close to where I live as a show case. The temperatures were recorded with the <a href="/components/sensor.swiss_hydrological_data/">Swiss Hydrological Data sensor</a> and the name of the sensor is <code>sensor.aare</code>.</p>

<p>The database is stored at <code>&lt;path to config dir&gt;/.homeassistant/home-assistant_v2.db</code> as <a href="https://www.sqlite.org/">SQLite database</a>. In all examples we are going to use the path: <code>/home/ha/.homeassistant/home-assistant_v2.db</code></p>

<p>If you are just curious what’s stored in your database then you can use the <code>sqlite3</code> command-line tool or a graphical one like <a href="http://sqlitebrowser.org/">DB Browser for SQLite</a>.</p>

<p>The table that is holding the states is called <code>states</code>. The <code>events</code> tables is responsible for storing the events which occurred. So, we will first check how many entries there are in the <code>states</code> table. <code>sqlite3</code> needs to know where the databases is located. To work with your database make sure that Home Assistant is not running or create a copy of the existing database. It’s recommended to work with a copy.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ sqlite3 /home/ha/.homeassistant/home-assistant_v2.db 
SQLite version 3.11.0 2016-02-15 17:29:24
sqlite&gt; SELECT count(*) FROM states;
24659
</pre></div>
</div>
</div>

<p>Let’s have a look at a sample <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> query. This query will show all states in a period for the sensor <code>sensor.aare</code>.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="class">SELECT</span> state, last_changed <span class="keyword">FROM</span> states
  <span class="keyword">WHERE</span>
    entity_id = <span class="string"><span class="delimiter">'</span><span class="content">sensor.aare</span><span class="delimiter">'</span></span>
  <span class="keyword">AND</span>
     last_changed <span class="keyword">BETWEEN</span>
    <span class="string"><span class="delimiter">'</span><span class="content">2016-07-05 00:00:00.000000</span><span class="delimiter">'</span></span> <span class="keyword">AND</span> <span class="string"><span class="delimiter">'</span><span class="content">2016-07-07 00:00:00.000000</span><span class="delimiter">'</span></span>;
</pre></div>
</div>
</div>

<p>The SQL statement can be formed that it fits exactly what you need. This means that you can process the data in any way you want for further use. Often it makes sense to eliminate certain entries like <code>Unknown</code> or peaks.</p>

<p>If the above query is executed in DB Browser for SQLite you would be able to save the sensor’s graph as png.</p>

<p class="img">
  <img src="https://home-assistant.io/images/blog/2016-07-reporting/db-browser.png" />
  Visualization with DB Browser for SQLite
</p>

<p>You may ask: Why not do this with LibreOffice Calc or another spreadsheet application? As most spreadsheet applications are not able to work directly with SQLite database we are going to export the data from the database to <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a>.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>$ sqlite3 -header -csv /home/ha/.homeassistant/home-assistant_v2.db &quot;SELECT last_changed, state FROM states WHERE entity_id = 'sensor.aare' AND last_changed BETWEEN '2016-07-05 00:00:00.000000' AND '2016-07-07 00:00:00.000000';&quot; &gt; sensor.csv
</pre></div>
</div>
</div>

<p>The ordering for the <code>SELECT</code> was changed to get the time stamps first and then the state. Now we can import the CSV file into the application of your choice, here it’s LibreOffice Calc.</p>

<p class="img">
  <img src="https://home-assistant.io/images/blog/2016-07-reporting/libreoffice-import.png" />
  Import of the CSV file 
</p>

<p>After the import a graph can be created over the existing data.</p>

<p class="img">
  <img src="https://home-assistant.io/images/blog/2016-07-reporting/libreoffice-graph.png" />
  Graph in LibreOffice
</p>

<p>You can also use <a href="http://matplotlib.org/">matplotlib</a> to generate graphs as an alternative to a spreadsheet application. This is a powerful Python 2D plotting library. With the built-in support for SQLite in Python it will only take a couple lines of code to visualize your data.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">import</span> <span class="include">sqlite3</span>
<span class="keyword">from</span> <span class="include">matplotlib</span> <span class="keyword">import</span> <span class="include">dates</span>
<span class="keyword">import</span> <span class="include">matplotlib.pyplot</span> <span class="keyword">as</span> plt

<span class="keyword">import</span> <span class="include">homeassistant.util.dt</span> <span class="keyword">as</span> dt

values = []
timestamps = []

conn = sqlite3.connect(<span class="string"><span class="delimiter">'</span><span class="content">/home/ha/.homeassistant/home-assistant_v2.db</span><span class="delimiter">'</span></span>)
data = conn.execute(<span class="string"><span class="delimiter">&quot;</span><span class="content">SELECT state, last_changed FROM states WHERE </span><span class="delimiter">&quot;</span></span>
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">entity_id = 'sensor.aare' AND last_changed BETWEEN </span><span class="delimiter">&quot;</span></span>
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">'2016-07-05 00:00:00.000000' AND </span><span class="delimiter">&quot;</span></span>
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">'2016-07-07 00:00:00.000000'</span><span class="delimiter">&quot;</span></span>)

<span class="keyword">for</span> x <span class="keyword">in</span> data:
    timestamps.append(dates.date2num(dt.parse_datetime(x[<span class="integer">1</span>])))
    values.append(<span class="predefined">float</span>(x[<span class="integer">0</span>]))

plt.plot_date(x=timestamps, y=values, fmt=<span class="string"><span class="delimiter">&quot;</span><span class="content">r-</span><span class="delimiter">&quot;</span></span>)
plt.ylabel(<span class="string"><span class="delimiter">'</span><span class="content">Temperature</span><span class="delimiter">'</span></span>)
plt.xlabel(<span class="string"><span class="delimiter">'</span><span class="content">Time line</span><span class="delimiter">'</span></span>)

plt.savefig(<span class="string"><span class="delimiter">'</span><span class="content">sensor.png</span><span class="delimiter">'</span></span>)
</pre></div>
</div>
</div>

<p>Creating a connection to the database and executing a query is similar to the ways already seen. The return values from the query are splitted into two lists. The time stamps must be converted in an value which is accepted by matplotlib and then the graph is generated and saved as image.</p>

<p class="img">
  <img src="https://home-assistant.io/images/blog/2016-07-reporting/mpl-sensor.png" />
  Sensor graph generated by matplotlib
</p>

<p>Most of the graphs are pretty ugly. So, further beautification will be needed. If you have created a nice report including some amazing graphs then the Home Assistant community would be grateful for sharing them in our <a href="https://community.home-assistant.io/">forum</a>.</p>

]]></content>
  </entry>
  
</feed>
